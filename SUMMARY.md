# Summary

* [1. Introduction](introduction.md)
  * [What does "pragmatism" mean?](introduction/what-does-pragmatism-mean.md)
  * [The second chance](introduction/the-second-chance.md)
  * [Less is more](introduction/less-is-more.md)
  * [Tooling](introduction/tooling.md)
* [2. Roots of the evil](roots-of-the-evil.md)
  * [Null considered harmful](roots-of-the-evil/null-considered-harmful.md)
  * [Mutability can kill your hamster](roots-of-the-evil/mutability-can-kill-your-hamster.md)
  * Take care with side-effects
  * Loops are so 80's
  * The Hadouken effect
  * [Somebody stop this!](roots-of-the-evil/somebody-stop-this.md)
* [3. Meet ESLint](meet-eslint.md)
  * Restricting imperative syntax
  * Plugins to the rescue
* [4. Modules](modules.md)
  * The SOLID equivalence
  * Top-level declarations
* [5. The power of composition](the-power-of-composition.md)
  * Thinking in functions
  * Currying and partial application
  * Point-free programming
  * Piping and composing
  * Combinators
  * Lenses
* [6. Types](types.md)
  * Why types matter
  * Flow is your friend
  * Don't abuse polymorphism
  * Algebraic data types
* [7. Transforming values](transforming-values.md)
  * Lists
  * Objects
  * Functions
* [8. Monads, monoids and functors](monads-monoids-and-functors.md)
  * What the hell is a monad?
  * Dealing with dangerous snakes
  * Handling state
  * Exceptions are not the rule
* [9. Async programming](async-programming.md)
  * So you still don't understand promises?
  * Futures
  * Tasks
  * Working with processes
  * Generators and lazy evaluation
* [10. Welcome to Fantasy Land](welcome-to-fantasy-land.md)
  * Unicorns and rainbows
  * Static Land
* [11. Hacking the compiler](hacking-the-compiler.md)
  * Extending Babel
  * Sweet macros
* [12. A bit of theory](a-bit-of-theory.md)
  * Lambda calculus
* [13. Functional languages targeting JavaScript](functional-languages-targeting-javascript.md)
  * [LiveScript](functional-languages-targeting-javascript/livescript.md)
  * PureScript
  * ReasonML
  * Elm
  * ClojureScript
* [14. Solving real world problems](solving-real-world-problems.md)
  * Integrating with external libraries
  * Validating data
  * Playing with files
  * Network requests
  * Testing
* [15. Final considerations](final-considerations.md)
  * What should I learn now?

