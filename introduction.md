# ntroduction

This book is separated in 15 chapters with specific subsections:

1. **Introduction**: gives you a brief introduction about pragmatic software development, functional programming history and reason and how it is applicable to modern software development.
2. **Roots of the evil**: presents language features that are more harmful than beneficial and later focuses on alternatives to solve the problems introduced by them.
3. **Meet ESLint**: shows how to encourage writing functional code and restricting harmful language features by using a specific tool for that job.
4. **Modules**: focuses on how to organize modular code and functions according to their domain and structuring the file system of your program. There is a special focus on modular code, code that is not specific for the program, but that can be easily reused and help you writing less.
5. **The power of composition**: touches on what really functional programming is about and shows you how to create more complexes things by composing very simple ones. It is definitely like playing LEGO!
6. **Types**: provides an overview about how a type system behaves and tools for static type checking on JavaScript in order to reduce the number of bugs. It also provides a different overview about static type system, different from what is presented in most courses and tutorials.
7. **Transforming values**: talks about common data structures transformations and functions that help us modeling transformations and working with immutable data structures. We'll be using a library called Ramda to present it in practice.
8. **Monads, monoids and functors**: may look a bit theoretical, but will present, together with the concepts of the terms, the practical usage of them and how important they are on the design of a functional program and how they help us to handle errors and deal with the dangerous world that exist outside.
9. **Async programming**: is an overview about how to deal with time-dependent actions and asynchronous computations. We'll talk about promises, futures, generators and the task monad.
10. **Welcome to Fantasy Land**: shows what is Fantasy Land and how it helps different functional libraries to easily interact and work together and shows some libraries that are compliant to this specification.
11. **Hacking the compiler**: gives an overview about Babel and preprocessor tools for JavaScript that allow us to extend the language to reduce boilerplate and make it easier to model our problems. We'll present how to write plugins to the compiler and use already existing to write better code.
12. **A bit of theory**: is definitely the most theoretical part of the book. We present the roots of functional programming and possibly advanced concepts.
13. **Functional languages targeting JavaScript**: introduces four languages that compile to JavaScript and have a good interoperability with it, but with focus on the functional paradigm. Some are more restrictive than others, however, with restriction comes security and precictability.
14. **Solving real world problems**: presents common daily problems and functional approaches, step by step, to solve them. It is not only about solving problems, but solving problems in such way that they will generate less problems later.
15. **Final considerations**: is our "goodbye". It is not the conclusion, because software development approaches are evolving really fast, and assuming that a specific way to get the job done is the best for all the times is definitely foolish.